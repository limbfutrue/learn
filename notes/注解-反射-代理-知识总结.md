### **知识总结**

#### 一、注解

##### 	释义

​	Java注解（Annotation）又称Java标注，是JDK1.5引入的一种注释机制。注解是元数据的一种形式，提供于程序但不属于程序本身的数据。注解对他们注解的代码的操作没有直接影响。

##### 	声明

​	注解的生命使用@interface关键字，例子如下：

```
public @interface ClassName{
	
}
```

##### 	元注解

​	在定义注解时，注解类也可以使用其他的注解声明。对注解类型进行注解的注解类，称之为meta-annotaiton（元注解）。一般在自定义注解时，需要指定两个元注解：

​	@Target 指定可以应用于哪些类型

- ElementType.ANNOTATION_TYPE   应用于注解类型
- ElementType.CONSTRUCTOR 		 应用于构造函数
- ElementType.FIELD							应用于字段或属性
- ElementType.LOCAL_VARIABLE		应用于局部变量
- ElementType.METHOD					应用于方法
- ElementType.PACKAGE					应用于包声明
- ElementType.PARAMETER				应用于方法的参数
- ElementType.TYPE							应用于类

​	@Retention  标记注解的存储方式

- RetentionPolicy.SOURCE 	注解保留于源码阶段

- RetentionPolicy.CLASS 		注解保留于编译期阶段

- RetentionPolicy.RUNTIME	注解保留于运行时阶段

  

​	例子：

```
@Target({ElementType.Type,ElementType.FILED})//只允许注解在类和属性上标记该注解
@Retention(RetentionPolicy.SOURCE)//注解保留在源码级别中
public @interface ClassName{

}
```

​	注解类型元素：

```java
@Target(ElementType.FILED)//只允许注解在类和属性上标记该注解
@Retention(RetentionPolicy.SOURCE)//注解保留在源码级别中
public @interface ClassName{
	String value();//无默认值
	int age() default 1;//有默认值
}
//注：如果定义的注解中的类型元素无默认值，则必须要传值.
//注：如果只存在value传值的话，注解则可以省略“元素名=”。例：@ClassName("className")
```

```
public class MyClass{
	@ClassName(value="aaaaaa",age=18)
	int a;
}
```

##### 注解应用场景

​	SOURCE

​		RetentionPolicy.SOURCE	作用于源码级别的注解，可用于IDE语法检查，APT（注解处理器）等场景使用。编译之后注解会被丢弃。

​	CLASS

​		RetentionPolicy.CLASS	保留在class文件中。应用场景为字节码插庄等。如热修复。

​	RUNTIME

​		RetentionPolicy.RUNTIME	注解保留至运行时。在运行时可以结合反射获取注解中的所有信息

#### 二、反射

##### 反射机制主要提供以下功能

- 在运行时构造任意一个类的对象
- 在运行时获取或者修改任意一个类具有的成员变量或方法
- 在运行时调用任意一个对象的方法（属性）

##### 获取class类的三种方式

- 通过类名获取		类名.class
- 通过对象获取		对象.getClass()
- 通过全类名获取	Class.forName(全类名)，classLoader.loadClass(全类名)

##### 判断是否为某个类的实例

```
public native boolean isInstance(Object obj)
```

##### 判断是否为某个类的类型

```
public boolean isAssignableFrom(Class<?> cls)
```

##### 创建实例

```
Class<?> cls = String.class;//获取类
//方式一
String s = cls.newInstance();//获取对象
//方式二	根据构造器获取对象
Constructor cst = cls.getConstructor(String.class);
Object o = cst.newInstance("22222");
```

##### 得到构造器的方法

```
//获得使用特殊参数类型的public构造函数（包括父类）
Constructor getConstructor(Class[] params)
//获得类的所有公共构造函数
Constructor[] getConstructor()
//获得使用特殊参数类型的构造函数（包括私有）
Constructor getDeclaredConstructor(Class[] params)
//获得类的所有构造函数（与接入的级别无关）
Constructor[] getDeclaredConstructor()
```

##### 获取类的成员变量（字段）信息

###### 获取字段信息

```
//获取命名的公共字段
Field getFiled(String name)
//获得类的所有公共字段
Filed[] getFileds()
//获得类声明的字段  name字段名
Filed getDeclaredFiled(String name)
//获取类的所有地段
Filed[] getDeclaredFileds()
```

###### 获取方法信息

```
//获取使用特定参数类型的公共方法
Method getMethod(String name,Class[] params)
//获取所有类的所有公共方法
Method[] getMethods()
//获取使用特定参数类声明的方法
Method getDeclaredMethod(String name,Class[] params)
//获取类声明的所有方法
Method[] getDeclaredMethods()

```

###### 调用获取的方法

```
public Object invoke(Object obj,Object...args)
```

##### 利用反射创建数组

```
//通过Array.newInstance()创建数组对象，它的原型是：
public static Object newInstance(Class<?> componentType,int length)
```

##### 反射获取泛型的真是类型

​	当我们对一个泛型类进行反射时，需要的到泛型中的真实数据类型，来完成如json反序列化的操作。此时需要通
过 Type 体系来完成。 Type 接口包含了一个实现类(Class)和四个实现接口，他们分别是：
​	TypeVariable
​	泛型类型变量。可以泛型上下限等信息；
​	ParameterizedType
​	具体的泛型类型，可以获得元数据中泛型签名类型(泛型真实类型)
​	GenericArrayType
​	当需要描述的类型是泛型类的数组时，比如List[],Map[]，此接口会作为Type的实现。
​	WildcardType
​	通配符泛型，获得上下限信息；

###### TypeVariable

```
public class TestType <K extends Comparable & Serializable, V> {
    K key;
    V value;
    public static void main(String[] args) throws Exception {
        // 获取字段的类型
        Field fk = TestType.class.getDeclaredField("key");
        Field fv = TestType.class.getDeclaredField("value");
        TypeVariable keyType = (TypeVariable)fk.getGenericType();
        TypeVariable valueType = (TypeVariable)fv.getGenericType();
        // getName 方法
        System.out.println(keyType.getName()); // K
        System.out.println(valueType.getName()); // V
        // getGenericDeclaration 方法
        System.out.println(keyType.getGenericDeclaration()); // class com.test.TestType
        System.out.println(valueType.getGenericDeclaration()); // class com.test.TestType
        // getBounds 方法
        System.out.println("K 的上界:"); // 有两个
        for (Type type : keyType.getBounds()) { // interface java.lang.Comparable
        	System.out.println(type); // interface java.io.Serializable
        }
        System.out.println("V 的上界:"); // 没明确声明上界的, 默认上界是 Object
        for (Type type : valueType.getBounds()) { // class java.lang.Object
        	System.out.println(type);
        }
    }
}
```

###### ParameterizedType

```
public class TestType {
    Map<String, String> map;
    public static void main(String[] args) throws Exception {
        Field f = TestType.class.getDeclaredField("map");
        // java.util.Map<java.lang.String,java.lang.String>
        System.out.println(f.getGenericType()); 
        ParameterizedType pType = (ParameterizedType) f.getGenericType();
        System.out.println(pType.getRawType()); // interface java.util.Map
        for (Type type : pType.getActualTypeArguments()) {
        	System.out.println(type); // 打印两遍: class java.lang.String
        }
    }
}
```

###### GenericArrayType

```
public class TestType<T> {
    List<String>[] lists;
    public static void main(String[] args) throws Exception {
        Field f = TestType.class.getDeclaredField("lists");
        GenericArrayType genericType = (GenericArrayType) f.getGenericType();
        System.out.println(genericType.getGenericComponentType());
    }
}
```

###### WildcardType

```
public class TestType {
    private List<? extends Number> a; // 上限
    private List<? super String> b; //下限
    public static void main(String[] args) throws Exception {
        Field fieldA = TestType.class.getDeclaredField("a");
        Field fieldB = TestType.class.getDeclaredField("b");
        // 先拿到范型类型
        ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType();
        ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType();
        // 再从范型里拿到通配符类型
        WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[0];
        WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[0];
        // 方法测试
        System.out.println(wTypeA.getUpperBounds()[0]); // class java.lang.Number
        System.out.println(wTypeB.getLowerBounds()[0]); // class java.lang.String
        // 看看通配符类型到底是什么, 打印结果为: ? extends java.lang.Number
        System.out.println(wTypeA);
	}
}
```

###### Gson反序列化

```
static class Response<T> {
    T data;
    int code;
    String message;
    @Override
    public String toString() {
        return "Response{" +
        "data=" + data +
        ", code=" + code +
        ", message='" + message + '\'' +
        '}';
    }
    public Response(T data, int code, String message) {
        this.data = data;
        this.code = code;
        this.message = message;
    }
}
static class Data {
    String result;
    public Data(String result) {
    	this.result = result;
	}
    @Override
    public String toString() {
        return "Data{" +
            "result=" + result +
            '}';
    }
}
public static void main(String[] args) {
    Response<Data> dataResponse = new Response(new Data("数据"), 1, "成功");
    Gson gson = new Gson();
    String json = gson.toJson(dataResponse);
    System.out.println(json);
    //为什么TypeToken要定义为抽象类？
    Response<Data> resp = gson.fromJson(json, new TypeToken<Response<Data>>() {
    }.getType());
    System.out.println(resp.data.result);
}
```

在进行GSON反序列化时，存在泛型时，可以借助 TypeToken 获取Type以完成泛型的反序列化。但是为什么
TypeToken 要被定义为抽象类呢？
因为只有定义为抽象类或者接口，这样在使用时，需要创建对应的实现类，此时确定泛型类型，编译才能够将泛型
signature信息记录到Class元数据中。

#### 三、代理

##### 静态代理

代理模式是给某一个对象提供一个代理对象，并由代理对象控制原对象的引用。

![1641535511384](C:\Users\dada\AppData\Roaming\Typora\typora-user-images\1641535511384.png)

**抽象角色**：指代理角色和真实角色对外提供的公共方法，一般为一个接口
**真实角色**：需要实现抽象角色接口，定义了真实角色所要实现的业务逻辑，以便供代理角色调用。也就是真正的业
务逻辑在此。
**代理角色**：需要实现抽象角色接口，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附
加自己的操作。将统一的流程控制都放到代理角色中处理！

静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。一般
来说，被代理对象和代理对象是一对一的关系，当然一个代理对象对应多个被代理对象也是可以的。
静态代理，一对一则会出现时静态代理对象量多、代码量大，从而导致代码复杂，可维护性差的问题，一对多则代
理对象会出现扩展能力差的问题。

步骤 1

创建一个接口。

Image.java

```
public interface Image {   
	void display(); 
}
```

步骤 2

创建实现接口的实体类。

RealImage.java

```
public class RealImage implements Image {    
	private String fileName;    
	public RealImage(String fileName){ 
    	this.fileName = fileName;      
    	loadFromDisk(fileName);   
    }   
    @Override   
    public void display() {      
    	System.out.println("Displaying " + fileName);   
    }    
    private void loadFromDisk(String fileName){
    	System.out.println("Loading " + fileName);
    } 
}
```

ProxyImage.java

```
public class ProxyImage implements Image{    
	private RealImage realImage;   
	private String fileName;    
	public ProxyImage(String fileName){      
		this.fileName = fileName;   
	}    
	@Override
    public void display() {
    	if(realImage == null){        
        	realImage = new RealImage(fileName); 
        }      
        realImage.display();
    } 
}
```



步骤 3

当被请求时，使用 *ProxyImage* 来获取 *RealImage* 类的对象。

ProxyPatternDemo.java

```
public class ProxyPatternDemo {      
	public static void main(String[] args) { 
        Image image = new ProxyImage("test_10mb.jpg"); 
        // 图像将从磁盘加载 
        image.display(); 
        System.out.println(""); 
        // 图像不需要从磁盘加载
        image.display(); 
        }
    }
}
```

##### 动态代理

在运行时再创建代理类和其实例，因此显然效率更低。要完成这个场景，需要在运行期动态创建一个Class。JDK提供了 Proxy 来完成这件事情

实际上， Proxy.newProxyInstance 会创建一个Class，与静态代理不同，这个Class不是由具体的.java源文件编译
而来，即没有真正的文件，只是在内存中按照Class格式生成了一个Class。

