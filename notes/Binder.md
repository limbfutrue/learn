Binder

binder_init:驱动初始化,过程需要持有 binder_main_lock 同步锁；

binder_open:打开驱动设备

binder_mmap:映射

主要功能：首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；
然后再申请 1 个 page 大小的物理内存，再将同一块物理内存分别映射到内核虚
拟地址空间和用户虚拟内存空间，从而实现了用户空间的 Buffer 和内核空间的
Buffer 同步操作的功能。

binder_mmap 通过加锁，保证一次只有一个进程分配内存，保证多进程间的并
发访问

binder_ioctrl:数据操作





# 1.Binder  有什么优势

**性能方面**

 共享内存 0 次数据拷贝
 Binder 1 次数据拷贝
 Socket/管道/消息队列 2 次数据拷贝

**稳定性方面**

 Binder：基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好
 共享内存：虽然无需拷贝，但是控制复杂，难以使用
 从稳定性的角度讲，Binder 机制是优于内存共享的。

**安全性方面**

 传统的 IPC 没有任何安全措施，安全依赖上层协议来确保。
 传统的 IPC 方法无法获得对方可靠的进程用户 ID/进程 UI（UID/PID），从而无法鉴别对方身份。
 传统的 IPC 只能由用户在数据包中填入 UID/PID，容易被恶意程序利用。
 传统的 IPC 访问接入点是开放的，无法阻止恶意程序通过猜测接收方地址获得连接。
 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。

# 2.Binder  是如何做到一次拷贝的

**Binder**  借助了内存映射的方法，在内核空间和接收方用户空间的数据缓存区之间做了一层内存映射，就相当于直接拷贝到了接收方用户空间的数据缓存区 ， 从而减少了一次数据拷贝。

主要是因为 Linux 是使用虚拟内存寻址的方式，它有如下特性：
 用户空间的虚拟内存地址是映射到物理内存中的。
 对虚拟内存的读写实际上是对物理内存的读写，这个过程就是内存映射。
 这个内存映射过程是通过系统调用 mmap()来实现的。

# 3.Binder  机制是如何跨进程的

**Binder** 驱动在内核空间创建一块接收缓存区， 将内核缓存区、接收进程用户空间映射到同一接收缓存区，实现地址映射。然后发送进程通过系统调用（copy_from_user）将数据发送到内核缓存区。由于内核缓存区和接收进程用户空间存在映射关系，故相当于也发送了接收进程的用户空间，实现了跨进程通信。

# 4.说说四大组件的通信机制

## 1.activity

（1）一个 Activity 通常就是一个单独的屏幕（窗口）。
（2）Activity 之间通过 Intent 进行通信。
（3）android 应用中每一个 Activity 都必须要在 AndroidManifest.xml 配置文件中声明，否则系统将不识别也不执行该 Activity。

## 2.service

（1）service 用于在后台完成用户指定的操作。（服务的启动有两种）
1).当应用程序组件（如 activity）调用 startService()方法启动服务时，服务处于启动状态。
2).当应用程序组件调用 bindService()方法绑定到服务时，服务处于绑定状态。
(2)startService()与 bindService()区别：
 started service（启动服务）是由其他组件调用 startService()方法启动的，这导致服务的 onStartCommand()方法被调用。当服务是 started 状态时，其生命周期与启动它的组件无关，并且可以在后台无限期运行，即使启动服务的组件已经被销毁。因此，服务需要在完成任务后调用 stopSelf()方法停止，或者由其他组件调stopService()
方法停止。
 使用 bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止。
(3)开发人员需要在应用程序配置文件中声明全部的 service，使用<service></service>标签。
(4)Service 通常位于后台运行，它一般不需要与用户交互，因此 Service 组件没有图形用户界面。Service 组件需要继承 Service 基类。Service 组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。

## 3.content provider

（1）android 平台提供了 Content Provider 使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过 ContentResolver 类从该内容提供者中获取或存入数据。
（2）只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处是统一数据访问方式。
（3）ContentProvider 实现数据共享。ContentProvider 用于保存和获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方式，因为android 没有提供所有应用共同访问的公共存储区。
（4）开发人员不会直接使用 ContentProvider 类的对象，大多数是通过ContentResolver 对象实现对ContentProvider 的操作。
（5）ContentProvider 使用 URI 来唯一标识其数据集，这里的 URI 以 content://作为前缀，表示该数据由 ContentProvider 来管理。

## 4.broadcast receiver

（1）你的应用可以使用它对外部事件进行过滤，只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个 activity 或 serice 来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力，例如闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。
（2）广播接收者的注册有两种方法，分别是程序动态注册和 AndroidManifest 文件中进行静态注册。
（3）动态注册广播接收器特点是当用来注册的 Activity 关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器也是打开着的。也就是说哪怕 app 本身未启动，该 app 订阅的广播在触发时也会对它起作用。

## 5.为什么 Intent  不能传递大数据

Intent 携带信息的大小其实是受 Binder 限制。数据以 Parcel 对象的形式存放在Binder 传递缓存中。如果数据或返回值比传递 buffer 大，则此次传递调用失败并抛出 TransactionTooLargeException 异常。
Binder 传递缓存有一个限定大小，通常是 1Mb。但同一个进程中所有的传输共享缓存空间。多个地方在进行传输时，即时它们各自传输的数据不超出大小限制，TransactionTooLargeException 异常也可能会被抛出。在使用 Intent 传递数据时，1Mb 并不是安全上限。因为 Binder 中可能正在处理其它的传输工作。不同的机型和系统版本，这个上限值也可能会不同。