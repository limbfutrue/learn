#### 什么是进程和线程

**进程**：进程是程序运行资源分配的最小单位（资源包括，CPU、内存空间、磁盘等等）。

**线程**：线程是cup调度的最小单位。线程必须依赖进程而存在。

#### 什么是并行和并发

**并行**：指应用能够同时执行不同的任务。

**并发**：值应用能够交替执行不同的任务。（一般都是离不开时间，就是单位时间内并发量是多少）。

**两者区别**：一个是交替执行，一个是同时执行。

#### 高并发编程的意义、好处和注意事项

##### 好处

1、充分利用CUP资源

2、加快想用用户的时间

3、可以使代码块异步化，简单化

##### 注意的事项

1、线程之间的安全

一个进程里的多线程是资源共享的，都可以访问同一个内部地址当中的一个变量。一般都需要考虑线程同步，否则就可能会影响线程安全。

2、线程之间的死循环过程

在引入锁机制时，就有可能产生死锁的多线程问题。

3、线程太多了会将服务器资源耗尽

#### 启动线程的几种方式

1、继承Thread类

2、实现Runnable接口

#### 中止线程的方式

##### 1、线程自然中止

就是run方法执行完成，要么就是抛出一个未处理的异常导致线程提前结束。

##### 2、手动中止

使用stop(),interrupt(),isInterrupted(),Thread.interrupted()方法中止。

stop()：stop()方法在中止一个线程是不会保证线程资源的正常释放，因此会导致程序可能工作在不确定状态下。所以一般不建议使用。

interrupt(),isInterrupted(),Thread.interrupted():interrupt()该方法只是发了一个线程中断请求，线程不会立即停止自己的工作，也可能不会理会中断请求。因为线程是协作式的，不是抢占式的。线程通过检查自身中断标志是否被置为true来进行相应。线程通过方法isInterrupted()方法来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标志位改为false。

如果一个线程处于阻塞状态（如线程调用了sleep，join，wait）则在线程检查中断标识时如果发现中断标识为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标志位清除，重置为false。

不建议自定义一个取消标志位来中断线程的运行。因为run方法有阻塞调用时会无法审快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。

`注意：处于死锁状态的线程无法被中断。`

#### 理解run()和start()

start()方法让一个线程进入就绪队列等待分配cpu，分配到cpu后才调用实现的run()方法，start()方法不能重复调用。

run()方法是业务逻辑实现的地方，本质上就是一个普通的方法，可以重复执行，可以被单独调用。

#### 其他线程方法

yield():使当前线程让出cpu的占有权，但让出的时间是不可设定的。也不会释放锁资源，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行。

join():把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。（比如，在线程B中调用了线程A的join方法，直到线程A执行完毕后，才会继续执行线程B)。

sleep():线程休眠，不会释放锁资源。

wait():线程等待，会释放锁资源。

notify():通知一个在对象上等待的线程。使其从wait()方法返回，返回的前提是该线程获取了对象锁，否则会重新进入等待状态。

notifyAll():通知所有等待在该对象上的线程。

#### 线程池原理

##### 好处

1、**降低资源消耗**（通过重复利用已创建的线程降低线程的创建和销毁造成的消耗）。

2、**提高相应速度**（当任务到达时，任务可以不需要等到线程创建就能立即执行）。

3、**提高线程的可管理性**（线程是稀缺资源，如果无限制的创建，不仅仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以对线程进行统一分配、调优和监控）

##### JDK中线程池和工作机制

线程池的创建各个参数的含义

public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,

BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)

**corePoolSize**

线程池中的核心线程数。当提交一个任务时，线程池创建一个新线程执行任务，知道当前线程数等于corePoolSize;

如果当前线程数为corePoolSize时，继续提交的任务将被保存到阻塞队列中，等待被执行；

如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。

**maximumPoolSize**

线程池中允许的最大线程数。

如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。

**keepAliveTime**

线程空闲时存活的时间。

即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用。

**TimeUnit**

keepAliveTime的时间单位

**workQueue**

workQueue必须是BlockingQueue阻塞队列。

当线程池中的线程数超过corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。

**阻塞队列**

1、支持阻塞的插入方法：意思是当队列满时，队列会堵塞插入元素的线程，直到队列不满。

2、支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为不空。

**常用阻塞队列**

ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列。

LinkedBlockingQueue:一个由链表结构组成的有界阻塞队列。

PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列。

DelayQueue:一个使用优先级队列实现的无界阻塞队列。

SynchronousQueue:一个不存储元素的阻塞队列。

LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。

LinkedBlockingQueue:一个由链表结构组成的双向阻塞队列。

**RejectedExecutionHandler**(**饱和策略**)

线程池的饱和策略，当阻塞队列满了，并且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4中策略。

1、AbortPolicy:直接抛出异常，默认策略；

2、CallerRunsPolicy:用调用者所在的线程来执行任务；

3、DiscardOldestPolicy:丢弃阻塞队列中最靠前的任务，并执行当前任务；

4、DiscardPolicy:直接丢弃任务；

也可以根据应用场景实现RjectedExecutionHandler接口，自定义饱和策略。

##### 线程次工作机制

1、如果当前运行的线程数小于核心线程数（corePoolSize)，则创建新线程来执行任务（注意：执行这一步需要获取全局锁）。

2、当运行的线程等于或者多于核心线程数（corePoolSize），则将任务假如阻塞队列（BlockingQueue）。

3、如果阻塞队列已满，则创建新的线程来处理任务（需要获取全局锁）。

4、如果创建新的线程将使当前运行的线程数超出最大线程数（maximumPoolSize）任务将被拒绝，并调用饱和策略。

#### 什么是原子操作？如何实现原子操作？

假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。

实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争（事实上CPU的主要工作并非这些），同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重

实现原子操作还可以使用当前的处理器基本都支持CAS()的指令，只不过每个厂家所实现的算法并不一样罢了，***\*每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。\****CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。**循环CAS就是在一个循环里不断的做*****\*CAS\******操作，直到成功为止。**怎么实现线程安全呢？语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。

#### CAS实现原子操作的三大问题

1)  ABA问题。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。

举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，这就是ABA问题。如果你是一个讲卫生讲文明的小伙子，不但关心水在不在，还要在你离开的时候水被人动过没有，因为你是程序员，所以就想起了放了张纸在旁边，写上初始值0，别人喝水前麻烦先做个累加才能喝水。

2)  循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

3)  只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。